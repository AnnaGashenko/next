<?php

// нужно всего один раз создать какой-то массив
array = array(
	0 => 'Украина',
	1 => 'Россия',
)

// по-этому в БД нам достаточно хранить информацию в цифрах 1,2,3,4,5
// эти цифры будут преобразовывать в полноценный вид Россия Украина
// в самой БД мы будем вставлять:
echo $country[1];

// Аналогично и с полом
array = array(
	0 => 'женщина',
	1 => 'мужчина',
)


ENUM - это массив в который мы записываем допустимые варианты для данного пола
В БД


// При ENUM 
array = array(
	0 => 'Украина',
	1 => 'Россия',
)
// принимает одно значение
`country` = 'Украина'

// При SET
array = array(
	0 => 'Украина',
	1 => 'Россия',
)
// может принимать одва значения
`country` = 'Украина', 'Россия' // каждая страна по 1 байту

// в MySQL
'' !== NULL
// пустота не равна NULL
// по логике MySQL пустые значения должны быть NULL
-> нельзя составить запрос, что мы проверяем и пустоту и NULL они живут по своей природе отдельно


// Если мы хотим проверить на пустоту
WHERE `text` = ''
// Если мы хотим проверить на NULL
WHERE `text` IS NULL


// Если мы хотим проверить на NULL и на пустоту
WHERE `text` = '' AND `text` IS NULL 
// По-этому мы не будем в ближайщее время пользоваться NULL 


Кодировка
_bin - РЕГИСТРОЗАВИСИМЫЙ
_ci - РЕГИСТРОНЕЗАИСИМЫЙ

_bin - хорошо использовать для паролей 
можно применять как большие так и маленькие буквы
InpOst12334

___________________________________________________

Атрибуты
- Unsigned

// допустимо вариантов 256
TYNYINT(1) 256 

от 0 до 255
от -127 до 127

// только положительные Unsigned
от 0 до 255

// если не указать атрибут Unsigned
от -127 до 127

id (int)
-250.000 до 250.000
UNSIGNED:
0 до 500.000
// отрицательные цисла забирают на себя половину вариантов

Страны
ID TYNYINT(1) AI - Автоинкримент
~200
// добавляя атрибут Unsigned мы убираем отрицательные значения
и тогда TYNYINT у нас будет не 127 вариантов, а 255


PARTITION - разбитие таблицы на несколько частей
Пользователей 1 миллиард пользователей
// Искать такое каоличество не возможно
- Нужно разбить таблицу на нескоько мелких таблиц
ПЕРВАЯ: от 1 до 10 000 000 (ID)
ВТОРАЯ: от 10 000 001 до 20 000 000 (ID)
// Это оптимизация - будет хватать памяти в сисмете,
// чтоб работать с какой то определенной таблицей

Например, была таблица users
// чтобы не далать таблицы
users1, users2, users3

// существует такое понятие как ПАРТИЦИЯ - PARTITION
// есть одна таблица users и она разбивается
users (внутри разбитие на блоки: users1, users2, users3)
// запрос делаем к общей таблице
SELECT * FROM `users`

_______________________________________________________

ТИПЫ ТАБЛИЦ
// Смотрим в коде, к чему мы чаще всего делаем запрос
// В нашем случае мы постоянно делаем выборку, нам подойдет ТАБЛИЦА №1 (InnoDB)
1) ТАБЛИЦА №1 (InnoDB)
БЫСТРЫЙ SELECT
в ущерб:
INSERT, UPDATE, DELETE

2) ТАБЛИЦА №2 (MyISAM)
БЫСТРЫЙ INSERT, UPDATE, DELETE
в ущерб:
SELECT

MEMORY:
// память - работает гораздо быстрее
8 gb Памяти
1tb Винчестер

таблица MEMORY означает, что вся таблица создана внутри памяти
- но нам она не подходит тем, что при перезагрузке винчестера, 
все данные в таблице удаляются

____________________________________________________________

Есть такое понятие в MySQL как блокирование таблицы

В Одном скрипте мы обращаемся ко всем 3-м таблицам
ТАБЛИЦА 1 => ТАБЛИЦА 2 => ТАБЛИЦА 3

Например, нам нужно удалить, что-то из ТАБЛИЦА 2
и сделать выборку
DELETE FROM `table2` + SELECT
// при (MyISAM) - выборка не наступит, пока информация не будет удалена
т.е. INSERT, UPDATE, DELETE первичнее SELECT
//  INSERT, UPDATE, DELETE блокируют таблицу на чтение SELECT

В (InnoDB) выборки SELECT работают в 2 раза быстрее, чем в (MyISAM)

-> Отсюда следует, что лучше работать в (InnoDB)

_____________________________________________________________

                             ИНДЕКСЫ
Это оглавления, как в книге по оглавлению нам удобнее найти
нужный раздел и нужную информацию

// Найти страницу
WHERE `событие` = 'Свадьба'
// Это событие мы нашли через закладку, потому что у нас есть оглавление
WHERE `главы` = 7

// По индексам и закладкам мы гораздо быстрее найдем, то что нам нужно

Например, найти login = inpost

AAA 
ABC
INPOST
IMPOST
IND
ING
ZZZ
Z
ZZZZZZZZZ
DDDDDD

WHERE `login` = 'inpost'

1. Ищет совпадения по первой букве (нашел)
INPOST
IMPOST
IND
ING
2. Ищет совпадения по второй букве (нашел)
INPOST
IND
ING
2. Ищет совпадения по третей букве (нашел)
INPOST

// и так далее пока не найдет полное совпадение

ИНДЕКСЫ БЫВАЮТ:

PRIMARY - один, и но является одновременно UNIQUE + INDEX
INDEX -
UNIQUE - говорит о том, что в БД не может быть 2-х одинаковых знечаний
inpost, inpost, inpost
FULLTEXT - ищет слово внутри текста

// Мы не делаем вот такой запрос к БД
WHERE `access` = 5 ?
// эта закладка нам не нужна, т.к. чем больше мы создаем закладок,
тем хуже(медленне работает наш сайт)
т.к. внутри PHP мы создали ассоциативный массив $_SESSION['user']
if(isset($_SESSION['user']['access'] && $_SESSION['user']['access'] == 5))
	echo 'Человек попал в админку';
}


// Но мы точно знаем, что мы делаем запросы по логину
// Вот здесь и нужно создавать закладку
WHERE `login` = 'inpost'

// Чтобы искть быстро и эффективно, достаточно создать индекс на поле login


Если мы хотим, чтоб наш сайт быстро работал и не падал, мы будем использовать индексы, т.е. наши закладки


// Для каждого запроса WHERE устанавливаем индекс
1. WHERE `login` = 'inpost' // уже создали
2. WHERE `login` = 'inpost' AND `password` = 'lalala'
3. WHERE `age` BETWEEN 18 AND 25
// BETWEEN тоже что
age >= 18 AND age <= 25

ДЛЯ ВСЕХ 3-х запросов необходимо создать все 3 индекса

2. WHERE `login` = 'inpost' AND `password` = 'lalala'
// создаем индексы для 2-х столбцов


DATE_FORMAT - конвертирует дату в нормальный ее вид
COUNT(*) as `cnt` - сколько всего записей существует
MAX(`access`)- максимальное число
MIN(`access`)- минимальное число
SUM(`access`) - сумма








