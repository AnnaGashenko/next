<?php
// 1. Создаем в корне папку в которую будем заливать наши файлы
// www -> uploaded
error_reporting(-1);
header('Content-Type: text/html; charset=utf-8');

function wtf($array, $stop = false) {
	echo '<pre>'.print_r($array,1).'</pre>';
	if(!$stop) {
		exit();
	}
}

// Проверим, что в [mime] => image/jpeg нужный формат файла
$types = array('image/gif','image/jpeg','image/png');

if(isset($_POST['submit'])){
	// С самого начала убеждаемся, что при загрузке файла ошибок не было,  [error] => 0
	if($_FILES['file']['error'] == 0){
		// чтобы получить размер картинки в Килобайтах - нужно
		// размер нашей картинки [size] => 78954 поделить на 1024 (78957/1024)
		if($_FILES['file']['size'] > 5000 || $_FILES['file']['size'] < 5000000){
			$temp = getimagesize($_FILES['file']['tmp_name']);
			// in_array - возвращает true, если элемент со значением $temp['mime'] присутствует в массиве $types;
			if(in_array($temp['mime'],$types)){
				// первым указываем сам файл $_FILES['file']['tmp_name']
				// вторым $name - с каким именем он будет загружен на сервер
				// Есть вероятность того, что 2 пользователя могут загрузить на сайт картинки с одинаковым именем
				// Чтобы этого избежать, ставим перед название текущее время
				// Время меняется каждую секунду, но есть вероятность, что в эту секунду загрузят картинку 25 человека, добавим ещё случайное число .rand(10000,99999)
				//$name = time().rand(10000,99999).'';
				// Выведит дату img случайное число
				// При таком раскладе, вероятность что имена файлов совпадут, ничтожно мала
				// Если бы использовали регистрацию пользователей, можно выводит имя пользователя
				//$name = '/uploaded/'.date('Ymd-His').'img'.rand(10000,99999).'-'.$_SESSION['user']['id'].'.jpg';
				$name = '/uploaded/original/'.date('Ymd-His').'img'.rand(10000,99999);
				// функцией move_uploaded_file() мы перемещаем файл в выбранную нами директорию из его временного хранилища.
				if(move_uploaded_file($_FILES['file']['tmp_name'],'.'.$name)){
					echo 'Наше изображение загруженно верно';
				} else {
					echo 'Изображение не загружено!';
				}
			} else {
				echo 'Не подходит тип файла, можно загружать только изображения';
			}

		} else {
			echo 'Размер изображения нам не подходит';
		}
	} else {
		echo 'Вы не загрузили файл!';
	}
	
	
	
	
	
/*	// Определяем формат
	// getimagesize - получаем инфо о файле
	$temp = getimagesize($_FILES['file']['tmp_name']);
	wtf($temp,1);
	// move_uploaded_file() - скопировать куда-то загруженный файл
	//move_uploaded_file();
	// $_FILES - суперглобальный массив
	// файлы находятся не в $_POST, а в $_FILES
	wtf($_FILES,1);*/
}


if(isset($_POST['submit'])){
	// файлы находятся не в $_POST, а в $_FILES
	// $_FILES - суперглобальный массив
	wtf($_FILES,1);
}



if(isset($_POST['submit'])){
	// getimagesize - получаем инфо о файле
	$temp = getimagesize($_FILES['file']['tmp_name']);
	wtf($temp,1);
	['tmp_name'] - путь к временной папке
}	
	
	
	// move_uploaded_file() скопировать куда-то загруженный файл
	wtf($_FILES,1);
папке


ДОМАШНЕЕ ЗАДАНИЕ:
3. Создать страницу для изменения личных данных пользователя
- Для пользователей добавить АВАТАР.
Размер аватара не может превышать 100х100

- С помощью функции getimagesize получаем размеры входного файла
не подходит размеры если:
w > 100 
h > 100

				// getimagesize - получаем инфо о файле				
				$size = getimagesize($_FILES['file']['tmp_name']);
                $filename = '/resize/small_'.$name;
				//Создаём новое изображение из «старого»
				if ($size['mime'] == 'image/jpeg') {
					$src = imagecreatefromjpeg($_FILES['file']['tmp_name']);
				} elseif ($size['mime'] == 'image/png') {
					$src = imagecreatefrompng($_FILES['file']['tmp_name']);
				} elseif ($size['mime'] == 'image/gif') {
					$src = imagecreatefromgif($_FILES['file']['tmp_name']);
				}

				//Берём числовое значение ширины фотографии, которое мы получили в первой строке и записываем это число в переменную
				$iw=$size[0];
				//Проделываем ту же операцию, что и в предыдущей строке, но только уже с высотой.
				$ih=$size[1];
 				if ($size[0] > 100 || $size[1] > 100){
					// если ширина больше высоты
					if($size[0] >= $size[1]) {
					//Ширину фотографии делим на 100 т.к. на выходе мы хотим получить фото шириной в 100 пикселей. В результате получаем коэфициент соотношения ширины оригинала с будущей превьюшкой.
						$koe=$iw/100;
						//Делим высоту изображения на коэфициент, полученный в предыдущей строке, и округляем число до целого в большую сторону — в результате получаем высоту нового изображения.
						$new_h=ceil ($ih/$koe);
					// если высота больше ширины
					} elseif($size[0] < $size[1]) {
						$koe=$ih/100;
						$new_w=ceil ($iw/$koe);
					}
				
					//Создаём пустое изображение шириной и высотой, которую мы вычислили в предыдущей строке.
					$dst=imagecreatetruecolor($new_w, $new_h);
					//Данная функция копирует прямоугольную часть изображения в другое изображение, плавно интерполируя пикселные значения таким образом, что, в частности, уменьшение размера изображения сохранит его чёткость и яркость.
					imagecopyresampled ($dst, $src, 0, 0, 0, 0, $new_w, $new_h, $iw, $ih);
					//Сохраняем полученное изображение в формате JPG
					imagejpeg($dst, $filename, 100);
					// Освобождаем память
					imagedestroy($src);
				}
				

				
				$size = getimagesize($_FILES['file']['tmp_name']);
				wtf($size,1);
				Array
				(
					[0] => 600 // ширина
					[1] => 604 // высота
					[2] => 2 // 
					[3] => width="600" height="604" 
					[bits] => 8
					[channels] => 3
					[mime] => image/jpeg 
				}



					wtf($_FILES,1);
					Array
					(
						[file] => Array //<input type="file" name="file">
							(
								[name] => 1.jpg
								[type] => image/jpeg - проблема в том, что не сервер отправляет данный тип, а пользователь отправляет этот тип. Может отправить вредоносный код. Есть вероятность взлома!!!
								[tmp_name] => Z:\tmp\phpA27.tmp - это временная папка, если нам нужен этот файл его нужно скопировать в нашу папку
								[error] => 0
								[size] => 78954
							)


Например пользователь загрузил файл 
w = 150 - (делаем w = 100)
h = 100 - (высчитываем h)

Считаем уравнение с одной неизвестной )))
150 - 100
100 - h

h = (100*100) / 150 
h = 67

Снова проверяем, входит ли ширина и высота в указынный диапазон

Если изображении 100х1 - изображение неверной пропорции
Если изображении 100х67 - все отлично, делаем resize




// imagecreatefromjpeg - Функция загружаем изображение из файла в память и возвращает его идентификатор 


// Данное изображение получаем в виде переменной через imagecreatefromjpeg
// Если файл ещё не загружен
$temp = imagecreatefromjpeg($_FILES['file']['tmp_name'])
// Тоже самое проделываем с новыми форматами
imagecreatefrompng($_FILES['file']['tmp_name'])
imagecreatefromgif($_FILES['file']['tmp_name'])

// Если файл уже загружен
$temp = imagecreatefromjpeg('.'.$name);

// затем создаем временное изображение с новыми размерами
$tmp = imagecreatetruecolor($newwidth, $newheight);


// С помощью ф-и imagecopyresampled делаем изменение размеров
imagecopyresampled($tmp,$src,0,0,0,0,$newwidth, $newheight,$width,$height);
// сохраняем новое изображение $tmp
imagejpeg($tmp,$filename,100);

imagedestroy($tmp);








?>





<!--Для того чтобы была возможность загружать файлы устанавливаем enctype="multipart/form-data"
иначе файлы не будут загружаться-->
<form action="" method="post" enctype="multipart/form-data">
  <!--Поле для ввода имени файла, который пересылается на сервер-->
  <input type="file" name="file">
  <input type="submit" name="submit" value="загрузить файл">
</form>


<!--

wtf($_FILES,1);
Array
(
    [file] => Array //<input type="file" name="file">
        (
            [name] => 1.jpg
            [type] => image/jpeg - проблема в том, что не сервер отправляет данный тип, а пользователь отправляет этот тип. Может отправить вредоносный код. Есть вероятность взлома!!!
            [tmp_name] => Z:\tmp\phpA27.tmp - это временная папка, если нам нужен этот файл его нужно скопировать в нашу папку
            [error] => 0
            [size] => 78954
        )

)

-->

wtf($temp,1);
Array
(
    [0] => 600 // ширина
    [1] => 604 // высота
    [2] => 2 // 
    [3] => width="600" height="604" 
    [bits] => 8
    [channels] => 3
    [mime] => image/jpeg // тип файла, но в отличии от [type] => image/jpeg он указан верно, атаки не будет!
)





<?php

// Изменяем немного код, чтоб не было лесенок


// Проверим, что в [mime] => image/jpeg нужный формат файла
$types = array('image/gif','image/jpeg','image/png');
$array2 = array('jpg','jpeg','png');

if(isset($_POST['submit'])){
	// С самого начала убеждаемся, что при загрузке файла ошибок не было,  [error] => 0
	if($_FILES['file']['error'] == 0){
		
		// чтобы получить размер картинки в Килобайтах - нужно
		// размер нашей картинки [size] => 78954 поделить на 1024 (78957/1024)
		// Если наш размер подходит
		if ($_FILES['file']['size'] < 5000 || $_FILES['file']['size'] > 5000000){
			echo 'Размер изображения нам не подходит';
		} else {
			// Проверяем расширение файла с помощью регулярного выражения
			// Достаем его окончание - то, что после точки!
			preg_match('#\.([a-z]+)$#iu',$_FILES['file']['name'],$matches);
			// Проверяем было ли найдено окончание после точки
			if(isset($matches[1])) {
				// Если пользователь загрузит файл с расширение в верхнем регистре JPEG
				// Делаем его в нижнем регистре с помощью mb_strtolower
				$matches[1] = mb_strtolower($matches[1]);
				
				// Определяем формат
				// getimagesize - получаем инфо о файле				
				$temp = getimagesize($_FILES['file']['tmp_name']);
				
				// Есть вероятность того, что 2 пользователя могут загрузить на сайт картинки с одинаковым именем
				// Чтобы этого избежать, ставим перед название текущее время
				// Время меняется каждую секунду, но есть вероятность, что в эту секунду загрузят картинку 25 человека, добавим ещё случайное число .rand(10000,99999)
				//$name = time().rand(10000,99999).'';
				// Выведит дату img случайное число
				// При таком раскладе, вероятность что имена файлов совпадут, ничтожно мала
				// Если бы использовали регистрацию пользователей, можно выводит имя пользователя
				//$name = '/uploaded/'.date('Ymd-His').'img'.rand(10000,99999).'-'.$_SESSION['user']['id'].'.jpg';
				
				// Создаем имя файла
				$name = '/uploaded/'.date('Ymd-His').'img'.rand(10000,99999);
							
				// in_array - возвращает true, если элемент со значением $temp['mime'] присутствует в массиве $array;
				// Если $matches[1] не входит в диапазон допустимых значний в массиве $array2
				if(!in_array($matches[1],$array2)){ // проверяем совпадения массивов
					echo 'Не подходит расширение изображения';	
					
				// in_array - возвращает true, если элемент со значением $temp['mime'] присутствует в массиве $array;
				// Провяряем тип файла
				} elseif(!in_array($temp['mime'],$array)){
					echo 'Не подходит тип файла, можно загружать только изображения';	
					
				// move_uploaded_file($filename, $destination) скопировать куда-то загруженный файл
				// функция проверяет, является ли файл $filename, только что закаченным и если это так, то перемещает его на новое место под именем $destination
				// первым параметром мы указываем сам файл $_FILES['file']['tmp_name']
				// вторым $name - с каким именем он будет загружен на сервер
				} elseif(!move_uploaded_file($_FILES['file']['tmp_name'],'.'.$name)){
					echo 'Изображение не загружено! Ошибка';
					
				} else {
					echo 'Наше изображение загруженно верно';
					// Если расширение совпало загружаем файл
					// Изображение добавили, можем сделать с ним что-нибудь ещё!
				}
			} else {
				// Если расширение не подходит - выводит ошибку
				echo 'Данный файл не является картинкой';	
			}
		}
	}
}


// Для того, чтобы загружались изображения, необходимо открыть файл .htaccess и записать
	// 1. Сколько памяти мы будем выделять на работу с данным изображением
	php_value memory_limit 128M
	
	// 2. Максимальный размер файла
	php_value upload_max_filesize 50M

	// 3. Общий размер post запроса (картинка + текст)
	php_value post_max_size 50M

	// 4. Время выполнения скрипта
	php_value max_input_time 3000
	
// В БД - создаем дополнительное поле img в него будем вставлять картинки




if(isset($_POST['submit'])){
	// С самого начала убеждаемся, что при загрузке файла ошибок не было,  [error] => 0
	if($_FILES['file']['error'] == 0){
		// чтобы получить размер картинки в Килобайтах - нужно
		// размер нашей картинки [size] => 78954 поделить на 1024 (78957/1024)
		if ($_FILES['file']['size'] < 5000 || $_FILES['file']['size'] > 5000000){
			echo 'Размер изображения нам не подходит';
		} 
	} else {
		echo 'Вы не загрузили файл!';
	}
}	





$temp = getimagesize($_FILES['file']['tmp_name']);
wtf($temp,1);
Array
(
    [0] => 600 // ширина
    [1] => 604 // высота
    [2] => 2 // 
    [3] => width="600" height="604" 
    [bits] => 8
    [channels] => 3
    [mime] => image/jpeg 
}
// Получаем содержание данного изображения
[mime] => image/jpeg 
// Но это не значит, что изображение будет 'pic.jpg

-> Проверим есть ли у нас в файле расширение .jpg
// Создаем массив с допустимыми расширениями
$array2 = array('jpg','jpeg','png');

-> Дальше через регулярные выражения проверяем совпадения
preg_match('#\.([a-z]+)$#iu',$_FILES['file']['name'],$matches);
// имя нахолится в $_FILES['file']['name']
wtf($_FILES,1);
Array
(
    [file] => Array 
        (
            [name] => 1.jpg
            [type] => image/jpeg 
            [tmp_name] => Z:\tmp\phpA27.tmp
            [error] => 0
            [size] => 78954
        )

)

wtf($matches[1],1);
-> вытаскиваем jpg без точки





//Определяем размер фотографии — ширину и высоту
$size=GetImageSize ("photo.jpg");
//Создаём новое изображение из «старого»
$src=ImageCreateFromJPEG ("photo.jpg");
//Берём числовое значение ширины фотографии, которое мы получили в первой строке и записываем это число в переменную
$iw=$size[0];
//Проделываем ту же операцию, что и в предыдущей строке, но только уже с высотой.
$ih=$size[1];
//Ширину фотографии делим на 150 т.к. на выходе мы хотим получить фото шириной в 150 пикселей. В результате получаем коэфициент соотношения ширины оригинала с будущей превьюшкой.
$koe=$iw/150;
//Делим высоту изображения на коэфициент, полученный в предыдущей строке, и округляем число до целого в большую сторону — в результате получаем высоту нового изображения.
$new_h=ceil ($ih/$koe);
//Создаём пустое изображение шириной в 150 пикселей и высотой, которую мы вычислили в предыдущей строке.
$dst=ImageCreateTrueColor (150, $new_h);
//Данная функция копирует прямоугольную часть изображения в другое изображение, плавно интерполируя пикселные значения таким образом, что, в частности, уменьшение размера изображения сохранит его чёткость и яркость.
ImageCopyResampled ($dst, $src, 0, 0, 0, 0, 150, $new_h, $iw, $ih);
//Сохраняем полученное изображение в формате JPG
ImageJPEG ($dst, "small_photo.jpg", 100);
imagedestroy($src);